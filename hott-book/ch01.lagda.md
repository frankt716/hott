```agda
{-# OPTIONS --without-K #-}
open import prelude hiding (_∘_ ; _×_ ; Σ)

module ch01 where
```

# Exercise 1.1.

Given functions $f : A → B$ and $g : B → C$, define their composition $g ∘ f : A → C$. Show that $f ∘ (g ∘ h) ≡ (f ∘ g) ∘ h$.
```agda
  _∘_ : {A B C : Type} → (g : B → C) → (f : A → B) → A → C
  (g ∘ f) a = g (f a)

  ∘-assoc : {A B C D : Type} → (f : C → D) → (g : B → C) → (h : A → B) → f ∘ (g ∘ h) ≡ (f ∘ g) ∘ h
  ∘-assoc f g h = refl (λ x → f (g (h x)))
```

# Exercise 1.2.

Derive the recursion principle for products using only the projections, and verify that the definitional equalities are valid. Do the same for Σ types.

```agda
  data _×_ (A B : Type) : Type where
    _,_ : A → B → A × B

  ×-rec : {A B C : Type} →
        (A → B → C) →
        A × B → C
  ×-rec f (a , b) = f a b

  π₁ : {A B : Type} → A × B → A
  π₁ (a , _) = a

  π₂ : {A B : Type} → A × B → B
  π₂ (_ , b) = b

  ×-rec-again : {A B C : Type} →
              (A → B → C) →
              A × B → C
  ×-rec-again f p = f (π₁ p) (π₂ p)
```

We see that `π₁ p :≡ a` and that `π₂ p :≡ b`. Thus, `×-rec-again` satisfies the required definitional equality.

```agda
  data Σ (A : Type) (B : A → Type) : Type where
    _,_ : (a : A) → (y : B a) → Σ A B

  Σ-rec : {A : Type} {B : A → Type} {C : Type} →
        ((a : A) → B a → C) →
        Σ A B → C
  Σ-rec f (a , b) = f a b

  Σπ₁ : {A : Type} {B : A → Type} → Σ A B → A
  Σπ₁ (a , _) = a

  Σπ₂ : {A : Type} {B : A → Type} → (p : Σ A B) → B (Σπ₁ p)
  Σπ₂ (_ , b) = b

  Σ-rec-again : {A : Type} {B : A → Type} {C : Type} →
              ((a : A) → B a → C) →
              Σ A B → C
  Σ-rec-again f p = f (Σπ₁ p) (Σπ₂ p)
```

Again, we see that `Σπ₁ p :≡ a` and `Σπ₂ p :≡ b`. Thus, `Σ-rec-again` satisfies the required definitional equality.

# Exercise 1.3.

Derive the induction principle for products, using only the projections and the propositional uniqueness principle.

```agda
  tr : {X : Type} {F : X → Type} {x y : X} → x ≡ y → F x → F y
  tr (refl _) = λ z → z

  ×-uniq : {A B : Type} →
         (p : A × B) → (π₁ p , π₂ p) ≡ p
  ×-uniq (a , b) = refl (a , b)

  ×-ind : {A B : Type} {C : A × B → Type} →
        ((a : A) → (b : B) → C (a , b)) →
        (p : A × B) → C p
  ×-ind {A} {B} {C} f p = tr {A × B} {C} {(π₁ p , π₂ p)} {p} (×-uniq p) (f (π₁ p) (π₂ p))

  Σ-uniq : {A : Type} {B : A → Type} →
         (p : Σ A B) → (Σπ₁ p , Σπ₂ p) ≡ p
  Σ-uniq (a , b) = refl (a , b)

  Σ-ind : {A : Type} {B : A → Type} {C : Σ A B → Type} →
        ((a : A) → (b : B a) → C (a , b)) →
        (p : Σ A B) → C p
  Σ-ind {A} {B} {C} f p = tr {Σ A B} {C} {(Σπ₁ p , Σπ₂ p)} {p} (Σ-uniq p) (f (Σπ₁ p) (Σπ₂ p))
```

# Exercise 1.4.

Use the iterator for ℕ to derive a function having the type of the recursor for ℕ. Show that the defining equations for the recursor hold propositionally for this function.
```agda
  ℕ-iter : {C : Type} →
         C → (C → C) → ℕ → C
  ℕ-iter c f zero = c
  ℕ-iter c f (suc n) = f (ℕ-iter c f n)

  ℕ-rec : {C : Type} →
        C → (ℕ → C → C) →
        ℕ → C
  ℕ-rec c f zero = c
  ℕ-rec c f (suc n) = f n (ℕ-rec c f n)

  ℕ-ind : {C : ℕ → Type} →
        C zero →
        ((n : ℕ) → C n → C (suc n)) →
        (n : ℕ) → C n
  ℕ-ind c f zero = c
  ℕ-ind c f (suc n) = f n (ℕ-ind c f n)

  ℕ-fun : {C : Type} →
             C → (ℕ → C → C) →
             ℕ → C
  ℕ-fun c f zero = c
  ℕ-fun c f (suc n) = ℕ-iter (ℕ-fun c f n) (f n) (suc zero)

  ℕ-fun-zero : {C : Type} → (c : C) → (f : ℕ → C → C) →
                  ℕ-fun c f zero ≡ c
  ℕ-fun-zero c f = refl c

  ℕ-fun-suc : {C : Type} → (c : C) (f : ℕ → C → C) (n : ℕ) →
                 ℕ-fun c f (suc n) ≡ f n (ℕ-rec c f n)
  ℕ-fun-suc c f = ℕ-ind (refl (f zero c)) λ n x → ap (f (suc n)) x
```
