```agda
{-# OPTIONS --without-K #-}
open import prelude hiding (_âˆ˜_ ; _Ã—_ ; Î£)

module ch01 where
```

# Exercise 1.1.

Given functions $f : A â†’ B$ and $g : B â†’ C$, define their composition $g âˆ˜ f : A â†’ C$. Show that $f âˆ˜ (g âˆ˜ h) â‰¡ (f âˆ˜ g) âˆ˜ h$.
```agda
  _âˆ˜_ : {A B C : Type} â†’ (g : B â†’ C) â†’ (f : A â†’ B) â†’ A â†’ C
  (g âˆ˜ f) a = g (f a)

  âˆ˜-assoc : {A B C D : Type} â†’ (f : C â†’ D) â†’ (g : B â†’ C) â†’ (h : A â†’ B) â†’ f âˆ˜ (g âˆ˜ h) â‰¡ (f âˆ˜ g) âˆ˜ h
  âˆ˜-assoc f g h = refl (Î» x â†’ f (g (h x)))
```

# Exercise 1.2.

Derive the recursion principle for products using only the projections, and verify that the definitional equalities are valid. Do the same for Î£ types.

```agda
  data _Ã—_ (A B : Type) : Type where
    _,_ : A â†’ B â†’ A Ã— B

  Ã—-rec : {A B C : Type} â†’
        (A â†’ B â†’ C) â†’
        A Ã— B â†’ C
  Ã—-rec f (a , b) = f a b

  Ï€â‚ : {A B : Type} â†’ A Ã— B â†’ A
  Ï€â‚ (a , _) = a

  Ï€â‚‚ : {A B : Type} â†’ A Ã— B â†’ B
  Ï€â‚‚ (_ , b) = b

  Ã—-rec-again : {A B C : Type} â†’
              (A â†’ B â†’ C) â†’
              A Ã— B â†’ C
  Ã—-rec-again f p = f (Ï€â‚ p) (Ï€â‚‚ p)
```

We see that `Ï€â‚ p :â‰¡ a` and that `Ï€â‚‚ p :â‰¡ b`. Thus, `Ã—-rec-again` satisfies the required definitional equality.

```agda
  data Î£ (A : Type) (B : A â†’ Type) : Type where
    _,_ : (a : A) â†’ (y : B a) â†’ Î£ A B

  Î£-rec : {A : Type} {B : A â†’ Type} {C : Type} â†’
        ((a : A) â†’ B a â†’ C) â†’
        Î£ A B â†’ C
  Î£-rec f (a , b) = f a b

  Î£Ï€â‚ : {A : Type} {B : A â†’ Type} â†’ Î£ A B â†’ A
  Î£Ï€â‚ (a , _) = a

  Î£Ï€â‚‚ : {A : Type} {B : A â†’ Type} â†’ (p : Î£ A B) â†’ B (Î£Ï€â‚ p)
  Î£Ï€â‚‚ (_ , b) = b

  Î£-rec-again : {A : Type} {B : A â†’ Type} {C : Type} â†’
              ((a : A) â†’ B a â†’ C) â†’
              Î£ A B â†’ C
  Î£-rec-again f p = f (Î£Ï€â‚ p) (Î£Ï€â‚‚ p)
```

Again, we see that `Î£Ï€â‚ p :â‰¡ a` and `Î£Ï€â‚‚ p :â‰¡ b`. Thus, `Î£-rec-again` satisfies the required definitional equality.

# Exercise 1.3.

Derive the induction principle for products, using only the projections and the propositional uniqueness principle.

```agda
  tr : {X : Type} {F : X â†’ Type} {x y : X} â†’ x â‰¡ y â†’ F x â†’ F y
  tr (refl _) = Î» z â†’ z

  Ã—-uniq : {A B : Type} â†’
         (p : A Ã— B) â†’ (Ï€â‚ p , Ï€â‚‚ p) â‰¡ p
  Ã—-uniq (a , b) = refl (a , b)

  Ã—-ind : {A B : Type} {C : A Ã— B â†’ Type} â†’
        ((a : A) â†’ (b : B) â†’ C (a , b)) â†’
        (p : A Ã— B) â†’ C p
  Ã—-ind {A} {B} {C} f p = tr {A Ã— B} {C} {(Ï€â‚ p , Ï€â‚‚ p)} {p} (Ã—-uniq p) (f (Ï€â‚ p) (Ï€â‚‚ p))

  Î£-uniq : {A : Type} {B : A â†’ Type} â†’
         (p : Î£ A B) â†’ (Î£Ï€â‚ p , Î£Ï€â‚‚ p) â‰¡ p
  Î£-uniq (a , b) = refl (a , b)

  Î£-ind : {A : Type} {B : A â†’ Type} {C : Î£ A B â†’ Type} â†’
        ((a : A) â†’ (b : B a) â†’ C (a , b)) â†’
        (p : Î£ A B) â†’ C p
  Î£-ind {A} {B} {C} f p = tr {Î£ A B} {C} {(Î£Ï€â‚ p , Î£Ï€â‚‚ p)} {p} (Î£-uniq p) (f (Î£Ï€â‚ p) (Î£Ï€â‚‚ p))
```

# Exercise 1.4.

Use the iterator for â„• to derive a function having the type of the recursor for â„•. Show that the defining equations for the recursor hold propositionally for this function.
```agda
  â„•-iter : {C : Type} â†’
         C â†’ (C â†’ C) â†’ â„• â†’ C
  â„•-iter c f zero = c
  â„•-iter c f (suc n) = f (â„•-iter c f n)

  â„•-rec : {C : Type} â†’
        C â†’ (â„• â†’ C â†’ C) â†’
        â„• â†’ C
  â„•-rec c f zero = c
  â„•-rec c f (suc n) = f n (â„•-rec c f n)

  â„•-ind : {C : â„• â†’ Type} â†’
        C zero â†’
        ((n : â„•) â†’ C n â†’ C (suc n)) â†’
        (n : â„•) â†’ C n
  â„•-ind c f zero = c
  â„•-ind c f (suc n) = f n (â„•-ind c f n)

  â„•-fun : {C : Type} â†’
        C â†’ (â„• â†’ C â†’ C) â†’
        â„• â†’ C
  â„•-fun c f n = Ï€â‚‚ (â„•-iter (zero , c) (Î» p â†’ (suc (Ï€â‚ p) , f (Ï€â‚ p) (Ï€â‚‚ p))) n)

  â„•-fun-zero : {C : Type} â†’ (c : C) â†’ (f : â„• â†’ C â†’ C) â†’
             â„•-fun c f zero â‰¡ c
  â„•-fun-zero c f = refl c

  â„•-fun-suc : {C : Type} â†’ (c : C) (f : â„• â†’ C â†’ C) (n : â„•) â†’
            â„•-fun c f (suc n) â‰¡ f n (â„•-rec c f n)
  â„•-fun-suc c f = â„•-ind (refl (f zero c)) Î» n eq â†’ apâ‚‚ f (lmaâ‚ (suc n)) (apâ‚‚ f (lmaâ‚ n) (lmaâ‚‚ n)) where
    lmaâ‚ : (n : â„•) â†’ Ï€â‚ (â„•-iter (zero , c) (Î» p â†’ suc (Ï€â‚ p) , f (Ï€â‚ p) (Ï€â‚‚ p)) n) â‰¡ n
    lmaâ‚ = â„•-ind (refl zero) Î» n eq â†’ ap suc eq

    lmaâ‚‚ : (n : â„•) â†’ Ï€â‚‚ (â„•-iter (zero , c) (Î» p â†’ suc (Ï€â‚ p) , f (Ï€â‚ p) (Ï€â‚‚ p)) n) â‰¡ â„•-rec c f n
    lmaâ‚‚ = â„•-ind (refl c) Î» n eq â†’ apâ‚‚ f (lmaâ‚ n) eq
```

# Exercise 1.5.

Show that if we define `A âˆ” B :â‰¡ Î£ (x : ğŸš) (ğŸš-rec A B x)`, then we can give a definition of `âˆ”-ind` for which the definitional equalities stated in Â§1.7 hold.
```agda
  data ğŸš : Type where
    ğŸ ğŸ : ğŸš

  ğŸš-rec : {i : Level} {C : Type i} â†’ C â†’ C â†’ ğŸš â†’ C
  ğŸš-rec câ‚€ câ‚ ğŸ = câ‚€
  ğŸš-rec câ‚€ câ‚ ğŸ = câ‚

  module _ where private
    _âˆ”_ : Type â†’ Type â†’ Type
    A âˆ” B = Î£ ğŸš (Î» (x : ğŸš) â†’ ğŸš-rec A B x)

    âˆ”-ind : {A B : Type} {C : A âˆ” B â†’ Type} â†’
          ((a : A) â†’ C (ğŸ , a)) â†’
          ((b : B) â†’ C (ğŸ , b)) â†’
          (b : A âˆ” B) â†’ C b
    âˆ”-ind f g (ğŸ , a) = f a
    âˆ”-ind f g (ğŸ , b) = g b
```

`(ğŸ , a)` encodes `inl(a)` and `(ğŸ , b)` encodes `inr(b)`. We see that `âˆ”-ind` satisfies the required definitional equalities.

# Exercise 1.9.

Define the type family `Fin : â„• â†’ ğ“¤` mentioned at the end of Â§1.3, and the dependent function `fmax : Î  (n : â„•) Fin(suc n)` mentioned in Â§1.4.
```agda
  data ğŸ˜ : Type where

  data _âˆ”_ (A B : Type) : Type where
    inl : A â†’ A âˆ” B
    inr : B â†’ A âˆ” B
    
  Fin : â„• â†’ Type
  Fin zero = ğŸ˜
  Fin (suc n) = (Fin n) âˆ” ğŸ™

  fmax : (n : â„•) â†’ Fin (suc n)
  fmax n = inr â‹†
```

# Exercise 1.10.

Show that the Ackermann function `ack : â„• â†’ â„• â†’ â„•` is definable using only `â„•-rec` satisfying the following equations:
- `ack 0 n :â‰¡ suc n`
- `ack (suc m) 0 :â‰¡ ack m 1`
- `ack (suc m) (suc n) :â‰¡ ack m (ack (suc m) n)`

```agda
  ack : â„• â†’ â„• â†’ â„•
  ack = â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r))
```

We can check that the definitional equalities are satisfied:
- â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) 0 n  
    = (Î» n â†’ suc n) n  
    = suc n

- â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) (suc m) 0  
    = (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) m (â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) m) 0  
    = (Î» f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) (â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) m) 0  
    = â„•-rec ((â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) m) (suc zero)) (Î» n r â†’ (â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) m) r) 0  
    = (â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) m) (suc zero)  
    = ack m 1

- â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) 1 1  
          :â‰¡ (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) 0 (â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) 0) 1  
          :â‰¡ (Î» f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) (â„•-rec (Î» n â†’ suc n) (Î» m f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) 0) 1  
          :â‰¡ (Î» f â†’ â„•-rec (f (suc zero)) (Î» n r â†’ f r)) (Î» n â†’ suc n) 1  
          :â‰¡ â„•-rec ((Î» n â†’ suc n) (suc zero)) (Î» n r â†’ (Î» n â†’ suc n) r) 1  
          :â‰¡ â„•-rec (suc (suc zero)) (Î» n r â†’ suc r) 1  
          :â‰¡ (Î» n r â†’ suc r) 0 (â„•-rec (suc (suc zero)) (Î» n r â†’ suc r) 0)  
          :â‰¡ (Î» r â†’ suc r) (suc (suc zero))  
  ack 1 1 :â‰¡ suc (suc (suc zero))
