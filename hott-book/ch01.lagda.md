```agda
{-# OPTIONS --without-K #-}
open import prelude hiding (_∘_ ; _×_ ; Σ)

module ch01 where
```

# Exercise 1.1.

Given functions $f : A → B$ and $g : B → C$, define their composition $g ∘ f : A → C$. Show that $f ∘ (g ∘ h) ≡ (f ∘ g) ∘ h$.
```agda
  _∘_ : {A B C : Type} → (g : B → C) → (f : A → B) → A → C
  (g ∘ f) a = g (f a)

  ∘-assoc : {A B C D : Type} → (f : C → D) → (g : B → C) → (h : A → B) → f ∘ (g ∘ h) ≡ (f ∘ g) ∘ h
  ∘-assoc f g h = refl (λ x → f (g (h x)))
```

# Exercise 1.2.

Derive the recursion principle for products using only the projections, and verify that the definitional equalities are valid. Do the same for Σ types.

```agda
  data _×_ (A B : Type) : Type where
    _,_ : A → B → A × B

  ×-rec : {A B C : Type} →
        (A → B → C) →
        A × B → C
  ×-rec f (a , b) = f a b

  π₁ : {A B : Type} → A × B → A
  π₁ (a , _) = a

  π₂ : {A B : Type} → A × B → B
  π₂ (_ , b) = b

  ×-rec-again : {A B C : Type} →
              (A → B → C) →
              A × B → C
  ×-rec-again f p = f (π₁ p) (π₂ p)
```

We see that `π₁ p :≡ a` and that `π₂ p :≡ b`. Thus, `×-rec-again` satisfies the required definitional equality.

```agda
  data Σ (A : Type) (B : A → Type) : Type where
    _,_ : (a : A) → (y : B a) → Σ A B

  Σ-rec : {A : Type} {B : A → Type} {C : Type} →
        ((a : A) → B a → C) →
        Σ A B → C
  Σ-rec f (a , b) = f a b

  Σπ₁ : {A : Type} {B : A → Type} → Σ A B → A
  Σπ₁ (a , _) = a

  Σπ₂ : {A : Type} {B : A → Type} → (p : Σ A B) → B (Σπ₁ p)
  Σπ₂ (_ , b) = b

  Σ-rec-again : {A : Type} {B : A → Type} {C : Type} →
              ((a : A) → B a → C) →
              Σ A B → C
  Σ-rec-again f p = f (Σπ₁ p) (Σπ₂ p)
```

Again, we see that `Σπ₁ p :≡ a` and `Σπ₂ p :≡ b`. Thus, `Σ-rec-again` satisfies the required definitional equality.

# Exercise 1.3.

Derive the induction principle for products, using only the projections and the propositional uniqueness principle.

```agda
  tr : {X : Type} {F : X → Type} {x y : X} → x ≡ y → F x → F y
  tr (refl _) = λ z → z

  ×-uniq : {A B : Type} →
         (p : A × B) → (π₁ p , π₂ p) ≡ p
  ×-uniq (a , b) = refl (a , b)

  ×-ind : {A B : Type} {C : A × B → Type} →
        ((a : A) → (b : B) → C (a , b)) →
        (p : A × B) → C p
  ×-ind {A} {B} {C} f p = tr {A × B} {C} {(π₁ p , π₂ p)} {p} (×-uniq p) (f (π₁ p) (π₂ p))
```
